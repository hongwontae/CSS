만약 같은 스타일 시트를 사용하여 여러 페이지에 적용할 때 브라우저는 스타일 시트를 캐싱하여 새로운 페이지마다 다시 다운로드하지 않아도 된다.

* 선택자 => 페이지에 있는 모든 요소를 선택한다.

css id는 url 끝에 해시 기호(#)를 추가할 수 있게 해주고 브라우저는 페이지에 해당 요소로 즉시 이동한다.

css id,class는 kebab-case을 사용하는 것이 좋다. => 모두 소문자로 적고, 단어와 단어사이에 -붙인다.
띄어쓰기는 하지 않는다.

css 우선순위(명시도라고 부른다.)
인라인 css > id 선택자 > 클래스 선택자 > 태그 선택자 > 전체 선택자 > 브라우저 기본값 > 상속값
=> 같은 영역에서 충돌이 발생하면 밑의 코드가 작동된다. (위에서 읽어가서..)

케스케이딩은 스타일 시트의 약자로 케스케이딩하다는 뜻은 여러 스타일이 같은 요소에 적용될 수 있다는 뜻이다. => 그래서 명시도가 나온 것이다.

CSS 상속
어떤 요소가 부모 요소의 스타일을 상속한다는 뜻이다.
상속은 가장 명시도가 낮다.
상속은 간접 부모나 직접 부모 둘 다 영향을 미친다.

*{} => 파싱 효율이 좋지 않다.
그래서 body{} 를 전체 선택자로 선택하는 경우가 많다.


결합자 추가하기
=> 속성 : inherti => 상속을 우선순위로 받아라, 명시도 증가 작업
결합자는 모든 명시도를 갖는다. => 우선순위가 제일 높다.
정보가 많은 규칙이 적은 규칙보다 우선한다. 구체적일수록 높다.


이론-결합자
1.+ 인접 형제 결합자
+ => h2+p => h2밑에 p태그만 선택된다는 뜻이다.
그렇다면? h2+p+a => h2밑에 p밑에 a만 선택된다는 뜻이다.
=> 동일한 부모에 존재해야 안에 존재해야 한다.

2. ~ 일반 형제 선택자
1.의 규칙을 따르는데, 조금더 유연한 방식이다.
=> 바로 밑에 오지 않아도 된다. 같은 수준에 존재하고 있으면 된다.

3. > 자식 결합자
부모의 자식을 선택한다.
ex) div > p {} => div가 부모이고 p가 자식을 요소만 선택한다.

4. 자손 결합자
띄어써서 두 개 쓰기
=> ex) div p {} => div상의 p태그를 모조리 선택한다.


























